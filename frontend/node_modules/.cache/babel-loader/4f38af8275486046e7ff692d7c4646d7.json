{"ast":null,"code":"import { encode, instantiate } from 'media-encoder-host';\nimport { addRecorderAudioWorkletModule, createRecorderAudioWorkletNode } from 'recorder-audio-worklet';\nimport { AudioBuffer, AudioBufferSourceNode, AudioWorkletNode, ConstantSourceNode, MediaStreamAudioSourceNode, MinimalAudioContext, addAudioWorkletModule } from 'standardized-audio-context';\nconst ERROR_MESSAGE = 'Missing AudioWorklet support. Maybe this is not running in a secure context.'; // @todo This should live in a separate file.\n\nconst createPromisedAudioNodesEncoderIdAndPort = async (audioBuffer, audioContext, channelCount, mediaStream, mimeType) => {\n  const {\n    encoderId,\n    port\n  } = await instantiate(mimeType, audioContext.sampleRate);\n\n  if (AudioWorkletNode === undefined) {\n    throw new Error(ERROR_MESSAGE);\n  }\n\n  const audioBufferSourceNode = new AudioBufferSourceNode(audioContext, {\n    buffer: audioBuffer\n  });\n  const mediaStreamAudioSourceNode = new MediaStreamAudioSourceNode(audioContext, {\n    mediaStream\n  });\n  const recorderAudioWorkletNode = createRecorderAudioWorkletNode(AudioWorkletNode, audioContext, {\n    channelCount\n  });\n  return {\n    audioBufferSourceNode,\n    encoderId,\n    mediaStreamAudioSourceNode,\n    port,\n    recorderAudioWorkletNode\n  };\n};\n\nexport const createWebAudioMediaRecorderFactory = (createBlobEvent, createInvalidModificationError, createInvalidStateError, createNotSupportedError) => {\n  return (eventTarget, mediaStream, mimeType) => {\n    var _a;\n\n    const sampleRate = (_a = mediaStream.getAudioTracks()[0]) === null || _a === void 0 ? void 0 : _a.getSettings().sampleRate;\n    const audioContext = new MinimalAudioContext({\n      latencyHint: 'playback',\n      sampleRate\n    });\n    const length = Math.max(1024, Math.ceil(audioContext.baseLatency * audioContext.sampleRate));\n    const audioBuffer = new AudioBuffer({\n      length,\n      sampleRate: audioContext.sampleRate\n    });\n    const bufferedArrayBuffers = [];\n    const promisedAudioWorkletModule = addRecorderAudioWorkletModule(url => {\n      if (addAudioWorkletModule === undefined) {\n        throw new Error(ERROR_MESSAGE);\n      }\n\n      return addAudioWorkletModule(audioContext, url);\n    });\n    let abortRecording = null;\n    let intervalId = null;\n    let promisedAudioNodesAndEncoderId = null;\n    let promisedPartialRecording = null;\n    let isAudioContextRunning = true;\n\n    const dispatchDataAvailableEvent = arrayBuffers => {\n      eventTarget.dispatchEvent(createBlobEvent('dataavailable', {\n        data: new Blob(arrayBuffers, {\n          type: mimeType\n        })\n      }));\n    };\n\n    const requestNextPartialRecording = async (encoderId, timeslice) => {\n      const arrayBuffers = await encode(encoderId, timeslice);\n\n      if (promisedAudioNodesAndEncoderId === null) {\n        bufferedArrayBuffers.push(...arrayBuffers);\n      } else {\n        dispatchDataAvailableEvent(arrayBuffers);\n        promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n      }\n    };\n\n    const resume = () => {\n      isAudioContextRunning = true;\n      return audioContext.resume();\n    };\n\n    const stop = () => {\n      if (promisedAudioNodesAndEncoderId === null) {\n        return;\n      }\n\n      if (abortRecording !== null) {\n        mediaStream.removeEventListener('addtrack', abortRecording);\n        mediaStream.removeEventListener('removetrack', abortRecording);\n      }\n\n      if (intervalId !== null) {\n        clearTimeout(intervalId);\n      }\n\n      promisedAudioNodesAndEncoderId.then(async _ref => {\n        let {\n          constantSourceNode,\n          encoderId,\n          mediaStreamAudioSourceNode,\n          recorderAudioWorkletNode\n        } = _ref;\n\n        if (promisedPartialRecording !== null) {\n          promisedPartialRecording.catch(() => {\n            /* @todo Only catch the errors caused by a duplicate call to encode. */\n          });\n          promisedPartialRecording = null;\n        }\n\n        await recorderAudioWorkletNode.stop();\n        mediaStreamAudioSourceNode.disconnect(recorderAudioWorkletNode);\n        constantSourceNode.stop();\n        const arrayBuffers = await encode(encoderId, null);\n\n        if (promisedAudioNodesAndEncoderId === null) {\n          await suspend();\n        }\n\n        dispatchDataAvailableEvent([...bufferedArrayBuffers, ...arrayBuffers]);\n        bufferedArrayBuffers.length = 0;\n        eventTarget.dispatchEvent(new Event('stop'));\n      });\n      promisedAudioNodesAndEncoderId = null;\n    };\n\n    const suspend = () => {\n      isAudioContextRunning = false;\n      return audioContext.suspend();\n    };\n\n    suspend();\n    return {\n      get mimeType() {\n        return mimeType;\n      },\n\n      get state() {\n        return promisedAudioNodesAndEncoderId === null ? 'inactive' : isAudioContextRunning ? 'recording' : 'paused';\n      },\n\n      pause() {\n        if (promisedAudioNodesAndEncoderId === null) {\n          throw createInvalidStateError();\n        }\n\n        if (isAudioContextRunning) {\n          suspend();\n          eventTarget.dispatchEvent(new Event('pause'));\n        }\n      },\n\n      resume() {\n        if (promisedAudioNodesAndEncoderId === null) {\n          throw createInvalidStateError();\n        }\n\n        if (!isAudioContextRunning) {\n          resume();\n          eventTarget.dispatchEvent(new Event('resume'));\n        }\n      },\n\n      start(timeslice) {\n        var _a;\n\n        if (promisedAudioNodesAndEncoderId !== null) {\n          throw createInvalidStateError();\n        }\n\n        if (mediaStream.getVideoTracks().length > 0) {\n          throw createNotSupportedError();\n        }\n\n        eventTarget.dispatchEvent(new Event('start'));\n        const audioTracks = mediaStream.getAudioTracks(); // @todo TypeScript v4.4.2 removed the channelCount property from the MediaTrackSettings interface.\n\n        const channelCount = audioTracks.length === 0 ? 2 : (_a = audioTracks[0].getSettings().channelCount) !== null && _a !== void 0 ? _a : 2;\n        promisedAudioNodesAndEncoderId = Promise.all([resume(), promisedAudioWorkletModule.then(() => createPromisedAudioNodesEncoderIdAndPort(audioBuffer, audioContext, channelCount, mediaStream, mimeType))]).then(async _ref2 => {\n          let [, {\n            audioBufferSourceNode,\n            encoderId,\n            mediaStreamAudioSourceNode,\n            port,\n            recorderAudioWorkletNode\n          }] = _ref2;\n          mediaStreamAudioSourceNode.connect(recorderAudioWorkletNode);\n          await new Promise(resolve => {\n            audioBufferSourceNode.onended = resolve;\n            audioBufferSourceNode.connect(recorderAudioWorkletNode);\n            audioBufferSourceNode.start(audioContext.currentTime + length / audioContext.sampleRate);\n          });\n          audioBufferSourceNode.disconnect(recorderAudioWorkletNode); // Bug #17: Safari does throttle the processing on hidden tabs if there is no active audio output.\n\n          const constantSourceNode = new ConstantSourceNode(audioContext, {\n            offset: 0\n          });\n\n          constantSourceNode.onended = () => constantSourceNode.disconnect();\n\n          constantSourceNode.connect(audioContext.destination);\n          constantSourceNode.start();\n          await recorderAudioWorkletNode.record(port);\n\n          if (timeslice !== undefined) {\n            promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n          }\n\n          return {\n            constantSourceNode,\n            encoderId,\n            mediaStreamAudioSourceNode,\n            recorderAudioWorkletNode\n          };\n        });\n        const tracks = mediaStream.getTracks();\n\n        abortRecording = () => {\n          stop();\n          eventTarget.dispatchEvent(new ErrorEvent('error', {\n            error: createInvalidModificationError()\n          }));\n        };\n\n        mediaStream.addEventListener('addtrack', abortRecording);\n        mediaStream.addEventListener('removetrack', abortRecording);\n        intervalId = setInterval(() => {\n          const currentTracks = mediaStream.getTracks();\n\n          if ((currentTracks.length !== tracks.length || currentTracks.some((track, index) => track !== tracks[index])) && abortRecording !== null) {\n            abortRecording();\n          }\n        }, 1000);\n      },\n\n      stop\n    };\n  };\n};","map":{"version":3,"mappings":"AAAA,SAASA,MAAT,EAAiBC,WAAjB,QAAoC,oBAApC;AACA,SAASC,6BAAT,EAAwCC,8BAAxC,QAA8E,wBAA9E;AACA,SACIC,WADJ,EAEIC,qBAFJ,EAGIC,gBAHJ,EAIIC,kBAJJ,EAOIC,0BAPJ,EAQIC,mBARJ,EASIC,qBATJ,QAUO,4BAVP;AAcA,MAAMC,aAAa,GAAG,8EAAtB,C,CAEA;;AACA,MAAMC,wCAAwC,GAAG,OAC7CC,WAD6C,EAE7CC,YAF6C,EAG7CC,YAH6C,EAI7CC,WAJ6C,EAK7CC,QAL6C,KAM7C;EACA,MAAM;IAAEC,SAAF;IAAaC;EAAb,IAAsB,MAAMlB,WAAW,CAACgB,QAAD,EAAWH,YAAY,CAACM,UAAxB,CAA7C;;EAEA,IAAId,gBAAgB,KAAKe,SAAzB,EAAoC;IAChC,MAAM,IAAIC,KAAJ,CAAUX,aAAV,CAAN;EACH;;EAED,MAAMY,qBAAqB,GAAG,IAAIlB,qBAAJ,CAA0BS,YAA1B,EAAwC;IAAEU,MAAM,EAAEX;EAAV,CAAxC,CAA9B;EACA,MAAMY,0BAA0B,GAAG,IAAIjB,0BAAJ,CAA+BM,YAA/B,EAA6C;IAAEE;EAAF,CAA7C,CAAnC;EACA,MAAMU,wBAAwB,GAAGvB,8BAA8B,CAACG,gBAAD,EAAmBQ,YAAnB,EAAiC;IAAEC;EAAF,CAAjC,CAA/D;EAEA,OAAO;IAAEQ,qBAAF;IAAyBL,SAAzB;IAAoCO,0BAApC;IAAgEN,IAAhE;IAAsEO;EAAtE,CAAP;AACH,CAlBD;;AAoBA,OAAO,MAAMC,kCAAkC,GAAyC,CACpFC,eADoF,EAEpFC,8BAFoF,EAGpFC,uBAHoF,EAIpFC,uBAJoF,KAKpF;EACA,OAAO,CAACC,WAAD,EAAchB,WAAd,EAA2BC,QAA3B,KAAuC;;;IAC1C,MAAMG,UAAU,GAAG,iBAAW,CAACa,cAAZ,GAA6B,CAA7B,OAA+B,IAA/B,IAA+BC,aAA/B,GAA+B,MAA/B,GAA+BA,GAAEC,WAAF,GAAgBf,UAAlE;IACA,MAAMN,YAAY,GAAG,IAAIL,mBAAJ,CAAwB;MAAE2B,WAAW,EAAE,UAAf;MAA2BhB;IAA3B,CAAxB,CAArB;IACA,MAAMiB,MAAM,GAAGC,IAAI,CAACC,GAAL,CAAS,IAAT,EAAeD,IAAI,CAACE,IAAL,CAAU1B,YAAY,CAAC2B,WAAb,GAA2B3B,YAAY,CAACM,UAAlD,CAAf,CAAf;IACA,MAAMP,WAAW,GAAG,IAAIT,WAAJ,CAAgB;MAAEiC,MAAF;MAAUjB,UAAU,EAAEN,YAAY,CAACM;IAAnC,CAAhB,CAApB;IACA,MAAMsB,oBAAoB,GAAkB,EAA5C;IACA,MAAMC,0BAA0B,GAAGzC,6BAA6B,CAAE0C,GAAD,IAAgB;MAC7E,IAAIlC,qBAAqB,KAAKW,SAA9B,EAAyC;QACrC,MAAM,IAAIC,KAAJ,CAAUX,aAAV,CAAN;MACH;;MAED,OAAOD,qBAAqB,CAACI,YAAD,EAAe8B,GAAf,CAA5B;IACH,CAN+D,CAAhE;IAQA,IAAIC,cAAc,GAAwB,IAA1C;IACA,IAAIC,UAAU,GAAkB,IAAhC;IACA,IAAIC,8BAA8B,GAA4C,IAA9E;IACA,IAAIC,wBAAwB,GAAyB,IAArD;IACA,IAAIC,qBAAqB,GAAG,IAA5B;;IAEA,MAAMC,0BAA0B,GAAIC,YAAD,IAAsC;MACrEnB,WAAW,CAACoB,aAAZ,CAA0BxB,eAAe,CAAC,eAAD,EAAkB;QAAEyB,IAAI,EAAE,IAAIC,IAAJ,CAASH,YAAT,EAAuB;UAAEI,IAAI,EAAEtC;QAAR,CAAvB;MAAR,CAAlB,CAAzC;IACH,CAFD;;IAIA,MAAMuC,2BAA2B,GAAG,OAAOtC,SAAP,EAA0BuC,SAA1B,KAA8D;MAC9F,MAAMN,YAAY,GAAG,MAAMnD,MAAM,CAACkB,SAAD,EAAYuC,SAAZ,CAAjC;;MAEA,IAAIV,8BAA8B,KAAK,IAAvC,EAA6C;QACzCL,oBAAoB,CAACgB,IAArB,CAA0B,GAAGP,YAA7B;MACH,CAFD,MAEO;QACHD,0BAA0B,CAACC,YAAD,CAA1B;QAEAH,wBAAwB,GAAGQ,2BAA2B,CAACtC,SAAD,EAAYuC,SAAZ,CAAtD;MACH;IACJ,CAVD;;IAYA,MAAME,MAAM,GAAG,MAAoB;MAC/BV,qBAAqB,GAAG,IAAxB;MAEA,OAAOnC,YAAY,CAAC6C,MAAb,EAAP;IACH,CAJD;;IAMA,MAAMC,IAAI,GAAG,MAAW;MACpB,IAAIb,8BAA8B,KAAK,IAAvC,EAA6C;QACzC;MACH;;MAED,IAAIF,cAAc,KAAK,IAAvB,EAA6B;QACzB7B,WAAW,CAAC6C,mBAAZ,CAAgC,UAAhC,EAA4ChB,cAA5C;QACA7B,WAAW,CAAC6C,mBAAZ,CAAgC,aAAhC,EAA+ChB,cAA/C;MACH;;MAED,IAAIC,UAAU,KAAK,IAAnB,EAAyB;QACrBgB,YAAY,CAAChB,UAAD,CAAZ;MACH;;MAEDC,8BAA8B,CAACgB,IAA/B,CACI,cAAkG;QAAA,IAA3F;UAAEC,kBAAF;UAAsB9C,SAAtB;UAAiCO,0BAAjC;UAA6DC;QAA7D,CAA2F;;QAC9F,IAAIsB,wBAAwB,KAAK,IAAjC,EAAuC;UACnCA,wBAAwB,CAACiB,KAAzB,CAA+B,MAAK;YAChC;UACH,CAFD;UAGAjB,wBAAwB,GAAG,IAA3B;QACH;;QAED,MAAMtB,wBAAwB,CAACkC,IAAzB,EAAN;QAEAnC,0BAA0B,CAACyC,UAA3B,CAAsCxC,wBAAtC;QACAsC,kBAAkB,CAACJ,IAAnB;QAEA,MAAMT,YAAY,GAAG,MAAMnD,MAAM,CAACkB,SAAD,EAAY,IAAZ,CAAjC;;QAEA,IAAI6B,8BAA8B,KAAK,IAAvC,EAA6C;UACzC,MAAMoB,OAAO,EAAb;QACH;;QAEDjB,0BAA0B,CAAC,CAAC,GAAGR,oBAAJ,EAA0B,GAAGS,YAA7B,CAAD,CAA1B;QAEAT,oBAAoB,CAACL,MAArB,GAA8B,CAA9B;QAEAL,WAAW,CAACoB,aAAZ,CAA0B,IAAIgB,KAAJ,CAAU,MAAV,CAA1B;MACH,CAzBL;MA4BArB,8BAA8B,GAAG,IAAjC;IACH,CA3CD;;IA6CA,MAAMoB,OAAO,GAAG,MAAoB;MAChClB,qBAAqB,GAAG,KAAxB;MAEA,OAAOnC,YAAY,CAACqD,OAAb,EAAP;IACH,CAJD;;IAMAA,OAAO;IAEP,OAAO;MACH,IAAIlD,QAAJ,GAAY;QACR,OAAOA,QAAP;MACH,CAHE;;MAKH,IAAIoD,KAAJ,GAAS;QACL,OAAOtB,8BAA8B,KAAK,IAAnC,GAA0C,UAA1C,GAAuDE,qBAAqB,GAAG,WAAH,GAAiB,QAApG;MACH,CAPE;;MASHqB,KAAK;QACD,IAAIvB,8BAA8B,KAAK,IAAvC,EAA6C;UACzC,MAAMjB,uBAAuB,EAA7B;QACH;;QAED,IAAImB,qBAAJ,EAA2B;UACvBkB,OAAO;UACPnC,WAAW,CAACoB,aAAZ,CAA0B,IAAIgB,KAAJ,CAAU,OAAV,CAA1B;QACH;MACJ,CAlBE;;MAoBHT,MAAM;QACF,IAAIZ,8BAA8B,KAAK,IAAvC,EAA6C;UACzC,MAAMjB,uBAAuB,EAA7B;QACH;;QAED,IAAI,CAACmB,qBAAL,EAA4B;UACxBU,MAAM;UACN3B,WAAW,CAACoB,aAAZ,CAA0B,IAAIgB,KAAJ,CAAU,QAAV,CAA1B;QACH;MACJ,CA7BE;;MA+BHG,KAAK,CAACd,SAAD,EAAmB;;;QACpB,IAAIV,8BAA8B,KAAK,IAAvC,EAA6C;UACzC,MAAMjB,uBAAuB,EAA7B;QACH;;QAED,IAAId,WAAW,CAACwD,cAAZ,GAA6BnC,MAA7B,GAAsC,CAA1C,EAA6C;UACzC,MAAMN,uBAAuB,EAA7B;QACH;;QAEDC,WAAW,CAACoB,aAAZ,CAA0B,IAAIgB,KAAJ,CAAU,OAAV,CAA1B;QAEA,MAAMK,WAAW,GAAGzD,WAAW,CAACiB,cAAZ,EAApB,CAXoB,CAYpB;;QACA,MAAMlB,YAAY,GACd0D,WAAW,CAACpC,MAAZ,KAAuB,CAAvB,GACM,CADN,GAEM,MAAiDoC,WAAW,CAAC,CAAD,CAAX,CAAetC,WAAf,GAA8BpB,YAA/E,MAA2F,IAA3F,IAA2FmB,aAA3F,GAA2FA,EAA3F,GAA+F,CAHzG;QAKAa,8BAA8B,GAAG2B,OAAO,CAACC,GAAR,CAAY,CACzChB,MAAM,EADmC,EAEzChB,0BAA0B,CAACoB,IAA3B,CAAgC,MAC5BnD,wCAAwC,CAACC,WAAD,EAAcC,YAAd,EAA4BC,YAA5B,EAA0CC,WAA1C,EAAuDC,QAAvD,CAD5C,CAFyC,CAAZ,EAK9B8C,IAL8B,CAKzB,eAA+G;UAAA,IAAxG,GAAG;YAAExC,qBAAF;YAAyBL,SAAzB;YAAoCO,0BAApC;YAAgEN,IAAhE;YAAsEO;UAAtE,CAAH,CAAwG;UACnHD,0BAA0B,CAACmD,OAA3B,CAAmClD,wBAAnC;UAEA,MAAM,IAAIgD,OAAJ,CAAaG,OAAD,IAAY;YAC1BtD,qBAAqB,CAACuD,OAAtB,GAAgCD,OAAhC;YACAtD,qBAAqB,CAACqD,OAAtB,CAA8BlD,wBAA9B;YACAH,qBAAqB,CAACgD,KAAtB,CAA4BzD,YAAY,CAACiE,WAAb,GAA2B1C,MAAM,GAAGvB,YAAY,CAACM,UAA7E;UACH,CAJK,CAAN;UAMAG,qBAAqB,CAAC2C,UAAtB,CAAiCxC,wBAAjC,EATmH,CAWnH;;UACA,MAAMsC,kBAAkB,GAAG,IAAIzD,kBAAJ,CAAuBO,YAAvB,EAAqC;YAAEkE,MAAM,EAAE;UAAV,CAArC,CAA3B;;UAEAhB,kBAAkB,CAACc,OAAnB,GAA6B,MAAMd,kBAAkB,CAACE,UAAnB,EAAnC;;UACAF,kBAAkB,CAACY,OAAnB,CAA2B9D,YAAY,CAACmE,WAAxC;UACAjB,kBAAkB,CAACO,KAAnB;UAEA,MAAM7C,wBAAwB,CAACwD,MAAzB,CAAgC/D,IAAhC,CAAN;;UAEA,IAAIsC,SAAS,KAAKpC,SAAlB,EAA6B;YACzB2B,wBAAwB,GAAGQ,2BAA2B,CAACtC,SAAD,EAAYuC,SAAZ,CAAtD;UACH;;UAED,OAAO;YAAEO,kBAAF;YAAsB9C,SAAtB;YAAiCO,0BAAjC;YAA6DC;UAA7D,CAAP;QACH,CA9BgC,CAAjC;QAgCA,MAAMyD,MAAM,GAAGnE,WAAW,CAACoE,SAAZ,EAAf;;QAEAvC,cAAc,GAAG,MAAK;UAClBe,IAAI;UACJ5B,WAAW,CAACoB,aAAZ,CAA0B,IAAIiC,UAAJ,CAAe,OAAf,EAAwB;YAAEC,KAAK,EAAEzD,8BAA8B;UAAvC,CAAxB,CAA1B;QACH,CAHD;;QAKAb,WAAW,CAACuE,gBAAZ,CAA6B,UAA7B,EAAyC1C,cAAzC;QACA7B,WAAW,CAACuE,gBAAZ,CAA6B,aAA7B,EAA4C1C,cAA5C;QAEAC,UAAU,GAAG0C,WAAW,CAAC,MAAK;UAC1B,MAAMC,aAAa,GAAGzE,WAAW,CAACoE,SAAZ,EAAtB;;UAEA,IACI,CAACK,aAAa,CAACpD,MAAd,KAAyB8C,MAAM,CAAC9C,MAAhC,IAA0CoD,aAAa,CAACC,IAAd,CAAmB,CAACC,KAAD,EAAQC,KAAR,KAAkBD,KAAK,KAAKR,MAAM,CAACS,KAAD,CAArD,CAA3C,KACA/C,cAAc,KAAK,IAFvB,EAGE;YACEA,cAAc;UACjB;QACJ,CATuB,EASrB,IATqB,CAAxB;MAUH,CArGE;;MAuGHe;IAvGG,CAAP;EAyGH,CAxMD;AAyMH,CA/MM","names":["encode","instantiate","addRecorderAudioWorkletModule","createRecorderAudioWorkletNode","AudioBuffer","AudioBufferSourceNode","AudioWorkletNode","ConstantSourceNode","MediaStreamAudioSourceNode","MinimalAudioContext","addAudioWorkletModule","ERROR_MESSAGE","createPromisedAudioNodesEncoderIdAndPort","audioBuffer","audioContext","channelCount","mediaStream","mimeType","encoderId","port","sampleRate","undefined","Error","audioBufferSourceNode","buffer","mediaStreamAudioSourceNode","recorderAudioWorkletNode","createWebAudioMediaRecorderFactory","createBlobEvent","createInvalidModificationError","createInvalidStateError","createNotSupportedError","eventTarget","getAudioTracks","_a","getSettings","latencyHint","length","Math","max","ceil","baseLatency","bufferedArrayBuffers","promisedAudioWorkletModule","url","abortRecording","intervalId","promisedAudioNodesAndEncoderId","promisedPartialRecording","isAudioContextRunning","dispatchDataAvailableEvent","arrayBuffers","dispatchEvent","data","Blob","type","requestNextPartialRecording","timeslice","push","resume","stop","removeEventListener","clearTimeout","then","constantSourceNode","catch","disconnect","suspend","Event","state","pause","start","getVideoTracks","audioTracks","Promise","all","connect","resolve","onended","currentTime","offset","destination","record","tracks","getTracks","ErrorEvent","error","addEventListener","setInterval","currentTracks","some","track","index"],"sources":["C:\\Users\\user\\Desktop\\GIRINEE\\S07P22A202\\frontend\\node_modules\\extendable-media-recorder\\src\\factories\\web-audio-media-recorder.ts"],"sourcesContent":["import { encode, instantiate } from 'media-encoder-host';\nimport { addRecorderAudioWorkletModule, createRecorderAudioWorkletNode } from 'recorder-audio-worklet';\nimport {\n    AudioBuffer,\n    AudioBufferSourceNode,\n    AudioWorkletNode,\n    ConstantSourceNode,\n    IAudioBuffer,\n    IMinimalAudioContext,\n    MediaStreamAudioSourceNode,\n    MinimalAudioContext,\n    addAudioWorkletModule\n} from 'standardized-audio-context';\nimport { IAudioNodesAndEncoderId } from '../interfaces';\nimport { TRecordingState, TWebAudioMediaRecorderFactoryFactory } from '../types';\n\nconst ERROR_MESSAGE = 'Missing AudioWorklet support. Maybe this is not running in a secure context.';\n\n// @todo This should live in a separate file.\nconst createPromisedAudioNodesEncoderIdAndPort = async (\n    audioBuffer: IAudioBuffer,\n    audioContext: IMinimalAudioContext,\n    channelCount: number,\n    mediaStream: MediaStream,\n    mimeType: string\n) => {\n    const { encoderId, port } = await instantiate(mimeType, audioContext.sampleRate);\n\n    if (AudioWorkletNode === undefined) {\n        throw new Error(ERROR_MESSAGE);\n    }\n\n    const audioBufferSourceNode = new AudioBufferSourceNode(audioContext, { buffer: audioBuffer });\n    const mediaStreamAudioSourceNode = new MediaStreamAudioSourceNode(audioContext, { mediaStream });\n    const recorderAudioWorkletNode = createRecorderAudioWorkletNode(AudioWorkletNode, audioContext, { channelCount });\n\n    return { audioBufferSourceNode, encoderId, mediaStreamAudioSourceNode, port, recorderAudioWorkletNode };\n};\n\nexport const createWebAudioMediaRecorderFactory: TWebAudioMediaRecorderFactoryFactory = (\n    createBlobEvent,\n    createInvalidModificationError,\n    createInvalidStateError,\n    createNotSupportedError\n) => {\n    return (eventTarget, mediaStream, mimeType) => {\n        const sampleRate = mediaStream.getAudioTracks()[0]?.getSettings().sampleRate;\n        const audioContext = new MinimalAudioContext({ latencyHint: 'playback', sampleRate });\n        const length = Math.max(1024, Math.ceil(audioContext.baseLatency * audioContext.sampleRate));\n        const audioBuffer = new AudioBuffer({ length, sampleRate: audioContext.sampleRate });\n        const bufferedArrayBuffers: ArrayBuffer[] = [];\n        const promisedAudioWorkletModule = addRecorderAudioWorkletModule((url: string) => {\n            if (addAudioWorkletModule === undefined) {\n                throw new Error(ERROR_MESSAGE);\n            }\n\n            return addAudioWorkletModule(audioContext, url);\n        });\n\n        let abortRecording: null | (() => void) = null;\n        let intervalId: null | number = null;\n        let promisedAudioNodesAndEncoderId: null | Promise<IAudioNodesAndEncoderId> = null;\n        let promisedPartialRecording: null | Promise<void> = null;\n        let isAudioContextRunning = true;\n\n        const dispatchDataAvailableEvent = (arrayBuffers: ArrayBuffer[]): void => {\n            eventTarget.dispatchEvent(createBlobEvent('dataavailable', { data: new Blob(arrayBuffers, { type: mimeType }) }));\n        };\n\n        const requestNextPartialRecording = async (encoderId: number, timeslice: number): Promise<void> => {\n            const arrayBuffers = await encode(encoderId, timeslice);\n\n            if (promisedAudioNodesAndEncoderId === null) {\n                bufferedArrayBuffers.push(...arrayBuffers);\n            } else {\n                dispatchDataAvailableEvent(arrayBuffers);\n\n                promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n            }\n        };\n\n        const resume = (): Promise<void> => {\n            isAudioContextRunning = true;\n\n            return audioContext.resume();\n        };\n\n        const stop = (): void => {\n            if (promisedAudioNodesAndEncoderId === null) {\n                return;\n            }\n\n            if (abortRecording !== null) {\n                mediaStream.removeEventListener('addtrack', abortRecording);\n                mediaStream.removeEventListener('removetrack', abortRecording);\n            }\n\n            if (intervalId !== null) {\n                clearTimeout(intervalId);\n            }\n\n            promisedAudioNodesAndEncoderId.then(\n                async ({ constantSourceNode, encoderId, mediaStreamAudioSourceNode, recorderAudioWorkletNode }) => {\n                    if (promisedPartialRecording !== null) {\n                        promisedPartialRecording.catch(() => {\n                            /* @todo Only catch the errors caused by a duplicate call to encode. */\n                        });\n                        promisedPartialRecording = null;\n                    }\n\n                    await recorderAudioWorkletNode.stop();\n\n                    mediaStreamAudioSourceNode.disconnect(recorderAudioWorkletNode);\n                    constantSourceNode.stop();\n\n                    const arrayBuffers = await encode(encoderId, null);\n\n                    if (promisedAudioNodesAndEncoderId === null) {\n                        await suspend();\n                    }\n\n                    dispatchDataAvailableEvent([...bufferedArrayBuffers, ...arrayBuffers]);\n\n                    bufferedArrayBuffers.length = 0;\n\n                    eventTarget.dispatchEvent(new Event('stop'));\n                }\n            );\n\n            promisedAudioNodesAndEncoderId = null;\n        };\n\n        const suspend = (): Promise<void> => {\n            isAudioContextRunning = false;\n\n            return audioContext.suspend();\n        };\n\n        suspend();\n\n        return {\n            get mimeType(): string {\n                return mimeType;\n            },\n\n            get state(): TRecordingState {\n                return promisedAudioNodesAndEncoderId === null ? 'inactive' : isAudioContextRunning ? 'recording' : 'paused';\n            },\n\n            pause(): void {\n                if (promisedAudioNodesAndEncoderId === null) {\n                    throw createInvalidStateError();\n                }\n\n                if (isAudioContextRunning) {\n                    suspend();\n                    eventTarget.dispatchEvent(new Event('pause'));\n                }\n            },\n\n            resume(): void {\n                if (promisedAudioNodesAndEncoderId === null) {\n                    throw createInvalidStateError();\n                }\n\n                if (!isAudioContextRunning) {\n                    resume();\n                    eventTarget.dispatchEvent(new Event('resume'));\n                }\n            },\n\n            start(timeslice?: number): void {\n                if (promisedAudioNodesAndEncoderId !== null) {\n                    throw createInvalidStateError();\n                }\n\n                if (mediaStream.getVideoTracks().length > 0) {\n                    throw createNotSupportedError();\n                }\n\n                eventTarget.dispatchEvent(new Event('start'));\n\n                const audioTracks = mediaStream.getAudioTracks();\n                // @todo TypeScript v4.4.2 removed the channelCount property from the MediaTrackSettings interface.\n                const channelCount =\n                    audioTracks.length === 0\n                        ? 2\n                        : (<MediaTrackSettings & { channelCount?: number }>audioTracks[0].getSettings()).channelCount ?? 2;\n\n                promisedAudioNodesAndEncoderId = Promise.all([\n                    resume(),\n                    promisedAudioWorkletModule.then(() =>\n                        createPromisedAudioNodesEncoderIdAndPort(audioBuffer, audioContext, channelCount, mediaStream, mimeType)\n                    )\n                ]).then(async ([, { audioBufferSourceNode, encoderId, mediaStreamAudioSourceNode, port, recorderAudioWorkletNode }]) => {\n                    mediaStreamAudioSourceNode.connect(recorderAudioWorkletNode);\n\n                    await new Promise((resolve) => {\n                        audioBufferSourceNode.onended = resolve;\n                        audioBufferSourceNode.connect(recorderAudioWorkletNode);\n                        audioBufferSourceNode.start(audioContext.currentTime + length / audioContext.sampleRate);\n                    });\n\n                    audioBufferSourceNode.disconnect(recorderAudioWorkletNode);\n\n                    // Bug #17: Safari does throttle the processing on hidden tabs if there is no active audio output.\n                    const constantSourceNode = new ConstantSourceNode(audioContext, { offset: 0 });\n\n                    constantSourceNode.onended = () => constantSourceNode.disconnect();\n                    constantSourceNode.connect(audioContext.destination);\n                    constantSourceNode.start();\n\n                    await recorderAudioWorkletNode.record(port);\n\n                    if (timeslice !== undefined) {\n                        promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n                    }\n\n                    return { constantSourceNode, encoderId, mediaStreamAudioSourceNode, recorderAudioWorkletNode };\n                });\n\n                const tracks = mediaStream.getTracks();\n\n                abortRecording = () => {\n                    stop();\n                    eventTarget.dispatchEvent(new ErrorEvent('error', { error: createInvalidModificationError() }));\n                };\n\n                mediaStream.addEventListener('addtrack', abortRecording);\n                mediaStream.addEventListener('removetrack', abortRecording);\n\n                intervalId = setInterval(() => {\n                    const currentTracks = mediaStream.getTracks();\n\n                    if (\n                        (currentTracks.length !== tracks.length || currentTracks.some((track, index) => track !== tracks[index])) &&\n                        abortRecording !== null\n                    ) {\n                        abortRecording();\n                    }\n                }, 1000);\n            },\n\n            stop\n        };\n    };\n};\n"]},"metadata":{},"sourceType":"module"}