{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useEffect, useState } from \"react\";\nimport { MediaRecorder, register } from 'extendable-media-recorder';\nimport { connect } from 'extendable-media-recorder-wav-encoder';\n\nconst useRecorder = () => {\n  _s();\n\n  const [audioURL, setAudioURL] = useState(\"\");\n  const [isRecording, setIsRecording] = useState(false);\n  const [recorder, setRecorder] = useState(null);\n  useEffect(() => {\n    // Lazily obtain recorder first time we're recording.\n    if (recorder === null) {\n      if (isRecording) {\n        requestRecorder().then(setRecorder, console.error);\n      }\n\n      return;\n    } // Manage recorder state.\n\n\n    if (isRecording) {\n      recorder.start();\n    } else {\n      recorder.stop();\n    } // Obtain the audio when ready.\n\n\n    const handleData = e => {\n      const blobDataInWebaFormat = e.data; // const blobDataInWavFormat = new File([blobDataInWebaFormat], 'recordfile.wav', {type: 'audio'})\n      // const blobDataInWavFormat = new File([blobDataInWebaFormat], 'record.wav', { 'type' : 'audio/webm; codecs=opus' })\n\n      setAudioURL(blobDataInWebaFormat);\n    };\n\n    recorder.addEventListener(\"dataavailable\", handleData);\n    return () => recorder.removeEventListener(\"dataavailable\", handleData);\n  }, [recorder, isRecording]);\n\n  const startRecording = () => {\n    setIsRecording(true);\n  };\n\n  const stopRecording = () => {\n    setIsRecording(false);\n  };\n\n  return [audioURL, isRecording, startRecording, stopRecording];\n};\n\n_s(useRecorder, \"JVc2yCoX0HlQc/J/jiBM4LjzGCo=\");\n\nasync function requestRecorder() {\n  await register(await connect());\n  const stream = await navigator.mediaDevices.getUserMedia({\n    audio: true\n  });\n  return new MediaRecorder(stream, {\n    mimeType: 'audio/wav'\n  });\n}\n\nexport default useRecorder;","map":{"version":3,"names":["useEffect","useState","MediaRecorder","register","connect","useRecorder","audioURL","setAudioURL","isRecording","setIsRecording","recorder","setRecorder","requestRecorder","then","console","error","start","stop","handleData","e","blobDataInWebaFormat","data","addEventListener","removeEventListener","startRecording","stopRecording","stream","navigator","mediaDevices","getUserMedia","audio","mimeType"],"sources":["C:/Users/user/Desktop/GIRINEE/S07P22A202/frontend/src/components/game/useRecorder.js"],"sourcesContent":["import { useEffect, useState } from \"react\";\r\nimport { MediaRecorder, register } from 'extendable-media-recorder';\r\nimport { connect } from 'extendable-media-recorder-wav-encoder';\r\n\r\nconst useRecorder = () => {\r\n  const [audioURL, setAudioURL] = useState(\"\");\r\n  const [isRecording, setIsRecording] = useState(false);\r\n  const [recorder, setRecorder] = useState(null);\r\n\r\n  useEffect(() => {\r\n    // Lazily obtain recorder first time we're recording.\r\n    if (recorder === null) {\r\n      if (isRecording) {\r\n        requestRecorder().then(setRecorder, console.error);\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Manage recorder state.\r\n    if (isRecording) {\r\n      recorder.start();\r\n    } else {\r\n      recorder.stop();\r\n    }\r\n\r\n    // Obtain the audio when ready.\r\n    const handleData = e => {\r\n      const blobDataInWebaFormat = e.data\r\n      // const blobDataInWavFormat = new File([blobDataInWebaFormat], 'recordfile.wav', {type: 'audio'})\r\n      // const blobDataInWavFormat = new File([blobDataInWebaFormat], 'record.wav', { 'type' : 'audio/webm; codecs=opus' })\r\n      setAudioURL(blobDataInWebaFormat);\r\n    };\r\n\r\n    recorder.addEventListener(\"dataavailable\", handleData);\r\n    return () => recorder.removeEventListener(\"dataavailable\", handleData);\r\n  }, [recorder, isRecording]);\r\n\r\n  const startRecording = () => {\r\n    setIsRecording(true);\r\n  };\r\n\r\n  const stopRecording = () => {\r\n    setIsRecording(false);\r\n  };\r\n\r\n  return [audioURL, isRecording, startRecording, stopRecording];\r\n};\r\n\r\nasync function requestRecorder() {\r\n  await register(await connect());\r\n\r\n  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n  return new MediaRecorder(stream, { mimeType: 'audio/wav' });\r\n}\r\nexport default useRecorder;\r\n"],"mappings":";;AAAA,SAASA,SAAT,EAAoBC,QAApB,QAAoC,OAApC;AACA,SAASC,aAAT,EAAwBC,QAAxB,QAAwC,2BAAxC;AACA,SAASC,OAAT,QAAwB,uCAAxB;;AAEA,MAAMC,WAAW,GAAG,MAAM;EAAA;;EACxB,MAAM,CAACC,QAAD,EAAWC,WAAX,IAA0BN,QAAQ,CAAC,EAAD,CAAxC;EACA,MAAM,CAACO,WAAD,EAAcC,cAAd,IAAgCR,QAAQ,CAAC,KAAD,CAA9C;EACA,MAAM,CAACS,QAAD,EAAWC,WAAX,IAA0BV,QAAQ,CAAC,IAAD,CAAxC;EAEAD,SAAS,CAAC,MAAM;IACd;IACA,IAAIU,QAAQ,KAAK,IAAjB,EAAuB;MACrB,IAAIF,WAAJ,EAAiB;QACfI,eAAe,GAAGC,IAAlB,CAAuBF,WAAvB,EAAoCG,OAAO,CAACC,KAA5C;MACD;;MACD;IACD,CAPa,CASd;;;IACA,IAAIP,WAAJ,EAAiB;MACfE,QAAQ,CAACM,KAAT;IACD,CAFD,MAEO;MACLN,QAAQ,CAACO,IAAT;IACD,CAda,CAgBd;;;IACA,MAAMC,UAAU,GAAGC,CAAC,IAAI;MACtB,MAAMC,oBAAoB,GAAGD,CAAC,CAACE,IAA/B,CADsB,CAEtB;MACA;;MACAd,WAAW,CAACa,oBAAD,CAAX;IACD,CALD;;IAOAV,QAAQ,CAACY,gBAAT,CAA0B,eAA1B,EAA2CJ,UAA3C;IACA,OAAO,MAAMR,QAAQ,CAACa,mBAAT,CAA6B,eAA7B,EAA8CL,UAA9C,CAAb;EACD,CA1BQ,EA0BN,CAACR,QAAD,EAAWF,WAAX,CA1BM,CAAT;;EA4BA,MAAMgB,cAAc,GAAG,MAAM;IAC3Bf,cAAc,CAAC,IAAD,CAAd;EACD,CAFD;;EAIA,MAAMgB,aAAa,GAAG,MAAM;IAC1BhB,cAAc,CAAC,KAAD,CAAd;EACD,CAFD;;EAIA,OAAO,CAACH,QAAD,EAAWE,WAAX,EAAwBgB,cAAxB,EAAwCC,aAAxC,CAAP;AACD,CA1CD;;GAAMpB,W;;AA4CN,eAAeO,eAAf,GAAiC;EAC/B,MAAMT,QAAQ,CAAC,MAAMC,OAAO,EAAd,CAAd;EAEA,MAAMsB,MAAM,GAAG,MAAMC,SAAS,CAACC,YAAV,CAAuBC,YAAvB,CAAoC;IAAEC,KAAK,EAAE;EAAT,CAApC,CAArB;EACA,OAAO,IAAI5B,aAAJ,CAAkBwB,MAAlB,EAA0B;IAAEK,QAAQ,EAAE;EAAZ,CAA1B,CAAP;AACD;;AACD,eAAe1B,WAAf"},"metadata":{},"sourceType":"module"}